1. 简述面向对象的设计思想。

面向对象是程序开发的机制，其特征为封装、继承、多态、抽象。

以面向对象的程序编写程序时，需要将复杂的项目抽象为多个对象互相协作的模型。

然后编写类型的结构，声明或实现类型的成员，即描述对象的特征和行为。

项目通过编写不同的类型完成不同的功能。

程序通过类的实例处理实际的问题。

解决面向过程的问题，解决代码重复使用的问题，面向对象是对事物抽象的描述。

2. 简述什么是静态成员和实例成员。

添加给构造函数自身的成员且只能供构造函数调用叫静态成员，不能通过实例成员调用；

由构造函数创建出来对象才能调用的属性和方法就叫实例成员，创建时可以直接给函数内部添加this；

静态成员优势：调用方法，构造函数直接调用；
实例成员优势：可以操作不同数据

3. 使用原型对象时，如何设置对象的成员。

直接在构造函数后面加prototype指向原型对象，然后添加对象的属性或者方法；或者使用对象字面量对来给原型对象赋值；


4. 简单介绍面向对象编程中，自调用函数的作用。

自调用函数可以创建独立的作用域，避免全局污染，避免全局变量或者方法命名冲突；
格式方法：（函数）（实参）

5. 简述面向对象编程的思路。

首先设置对象的构造函数，在构造函数中通过this设置不同的属性或方法，需要生成的对象要设置给原型对象，渲染到页面；在获取随机到对象元素坐标时候，可以另外在设置一个单独的对象js文件，这样在构造函数调用时候，可以直接调用单独的对象。

6. 简述原型链查找过程。

首先从原型对象实例出发，如果在实例对象中找到给定名字的属性，即可返回属性值，否则继续向上搜索原型对象，在原型对象中找给定名字的属性，如果在原型对象中找到该属性值，即可返回该值；

7. 描述函数声明与函数表达式的区别。

书写方式：首先函数声明定义的是函数名字，函数表达式是把函数赋值给变量，可以是匿名函数；
调用结果：函数声明调用的函数，函数表达式调用的是变量；
函数提升：函数声明前后都可以调用，可以函数提升，但是表达式不能；
不同版本浏览器中，例如if的函数中，无法进行函数声明提升，可以通过函数表达式的设置方式，进行函数提升，从而解决兼容性的问题；

8. 描述call、apply和bind方法各自的功能和特性。

call: 执行函数并传参，可以指定函数的this;返回值为函数本身的返回值；参数包括this指向的对象，和函数列表的参数带包；
apply:和call非常类似，但是第二个参数是函数的参数组成的数组，而不是列表的方式传参数；返回值同call;
bind:绑定函数，可以指定函数this,不能执行函数，可以传参，函数列表，此处同call；返回值为新的指定的this 函数；

9. JavaScript中callee和caller有何作用。

callee：指向arguments所指函数，函数本身，arguments的一个属性；
caller：函数的调用者,函数在哪个作用域调用，caller则是该范围值；如果在全局调用，返回的调用者为 null。

10. 什么是闭包？闭包的特点是什么。

一个函数对其周围状态引用捆绑在一起，这种组合就是闭包；闭包可以在内层函数中访问其外层函数作用域。
每当一个函数在js创建，闭包会同时被创建；闭包内函数成员一致存活，可以在函数外部读取函数内部成员；广义全局定义的函数就是闭包。

11. let、const、var定义变量的区别是什么

let let声明的变量，生成块级的作用域；不能被外部引用访问，适合for循环中设置的循环变量；let不会进行变量声明提升；

const let基础上只读的效果，恒量/常量；注意不能任意修改内部储存的值；对象内部的值可以添加新数据；

var 同一个作用域的变量名重复之后，会覆盖，函数只会在内部循环执行一次，会对全局作用域造成影响；

12. 箭头函数与普通函数的区别是什么

外形不同: 箭头函数使用箭头定义，普通函数中没有。箭头函数全都是匿名函数，普通函数可以有匿名函数，也可以有具名函数。箭头函数不能用于构造函数，普通函数可以用于构造函数，以此创建对象实例。

13. set和数组的区别是什么？set中如何增加、删除元素
set数据类型是新的，内部数据成员不允许重复，必须是唯一的；类似数组；
增加元素：
const s = new Set();
s.add();
console.log(s)
删除元素：s.delete();
检查：console.log(s.delete(2));看返回值是否为true;

14. ES6中如何实现类的继承

extends

用法：构造函数内部继承属性，调用父类的方法

class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    sayHi() {
        console.log('hi,my name is ${this.name}');
    }
}

class Student extends Person {
    constructor (name, age, number) {
        //通过super的方法在内部函数调用父类属性
        super(name, age);
        this.number = number
    }
    hello(){
        super.sayHi()
        console.log('学号是 ${this.number}')
    }
}
新的变量之后可以直接继承调用：
const s1 = new Student('tom', 18, 101);
s1.hello();

15. 类中的static关键字有什么作用

class类中的static关键字，表示声明的方法为静态的，内部可以写新的函数以及参数,方便后期调用静态方法即可；

class Person {
constructor(name, age){
this.name = name;
this.age = age;
}
static create(name, age){
return new Person(name, age)
}
}
//新的create方法下的对象；
const p1 = Person.create('zs', 19);
console.log(p1)
//显示Person{name: 'zs'; age: 19}

16. 类中的静态方法与普通函数的区别？如何定义静态方法
类中的静态方法是可以直接在后期新的方法对象中直接调用的，普通函数则需要重新再new 函数对象；
“类名.属性=function () {}”



